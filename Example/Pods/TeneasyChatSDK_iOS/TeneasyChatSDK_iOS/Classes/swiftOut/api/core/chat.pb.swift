// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api/core/chat.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///分页结构体
public struct Api_Core_Pagination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///当前页码
  public var page: Int32 = 0

  ///分页大小
  public var pagesize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 聊天会话列表
public struct Api_Core_ChatListQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 聊天会话列表
public struct Api_Core_ChatListQueryPageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var page: Api_Core_Pagination {
    get {return _page ?? Api_Core_Pagination()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var workerID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: Api_Core_Pagination? = nil
}

/// 聊天会话列表
public struct Api_Core_ChatListHistoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  ///开始查询时间
  public var start: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  ///结束
  public var end: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  /// 咨询id
  public var consultID: UInt32 = 0

  /// 用户id
  public var ownerID: Int32 = 0

  /// 用户昵称
  public var nickname: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_ChatListHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chats: [CommonChatItem] = []

  public var batch: CommonBatch {
    get {return _batch ?? CommonBatch()}
    set {_batch = newValue}
  }
  /// Returns true if `batch` has been explicitly set.
  public var hasBatch: Bool {return self._batch != nil}
  /// Clears the value of `batch`. Subsequent reads from it will return its default value.
  public mutating func clearBatch() {self._batch = nil}

  public var total: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _batch: CommonBatch? = nil
}

public struct Api_Core_ChatListQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chats: [CommonChatItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_ChatListQueryPageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///总量
  public var total: Int32 = 0

  public var chats: [CommonChatItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 标记已读
public struct Api_Core_ChatMarkReadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  /// 咨询类型
  public var consultID: Int64 = 0

  /// 消息ID
  public var msgID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_OrphanResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var workerID: Int32 = 0

  public var nick: String = String()

  public var avatar: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_MarkRepliedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  /// 咨询类型
  public var consultID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_ChatListQueryUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int32 = 0

  public var registerType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_OrphanReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  /// 咨询类型
  public var consultID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_GetChatSessionStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户ID
  public var tenantID: Int32 = 0

  /// 咨询类型
  public var consultID: Int64 = 0

  /// 用户id
  public var ownerID: Int32 = 0

  public var ownerRole: Int32 = 0

  /// 会话ID
  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_Core_GetChatSessionStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 商户ID
  public var tenantID: Int32 {
    get {return _storage._tenantID}
    set {_uniqueStorage()._tenantID = newValue}
  }

  /// 咨询类型
  public var consultID: Int64 {
    get {return _storage._consultID}
    set {_uniqueStorage()._consultID = newValue}
  }

  /// 用户id
  public var ownerID: Int32 {
    get {return _storage._ownerID}
    set {_uniqueStorage()._ownerID = newValue}
  }

  /// 用户角色
  public var ownerRole: Int32 {
    get {return _storage._ownerRole}
    set {_uniqueStorage()._ownerRole = newValue}
  }

  /// 多少秒前分配任务
  public var assignTime: Int64 {
    get {return _storage._assignTime}
    set {_uniqueStorage()._assignTime = newValue}
  }

  /// 会话多少秒前开始
  public var sessionStartTime: Int64 {
    get {return _storage._sessionStartTime}
    set {_uniqueStorage()._sessionStartTime = newValue}
  }

  /// 客户多少秒前发言
  public var clientMessageTime: Int64 {
    get {return _storage._clientMessageTime}
    set {_uniqueStorage()._clientMessageTime = newValue}
  }

  /// 客户多少秒前第一次发言
  public var clientFirstTime: Int64 {
    get {return _storage._clientFirstTime}
    set {_uniqueStorage()._clientFirstTime = newValue}
  }

  /// 客服id
  public var workerID: Int32 {
    get {return _storage._workerID}
    set {_uniqueStorage()._workerID = newValue}
  }

  /// 客服多少秒前是否在线
  public var workerPingTime: Int64 {
    get {return _storage._workerPingTime}
    set {_uniqueStorage()._workerPingTime = newValue}
  }

  /// 客服多少秒前第一次发言
  public var workerFirstTime: Int64 {
    get {return _storage._workerFirstTime}
    set {_uniqueStorage()._workerFirstTime = newValue}
  }

  /// 客服多少秒前发言
  public var workerMessageTime: Int64 {
    get {return _storage._workerMessageTime}
    set {_uniqueStorage()._workerMessageTime = newValue}
  }

  /// 咨询类型
  public var workerConsultID: Int64 {
    get {return _storage._workerConsultID}
    set {_uniqueStorage()._workerConsultID = newValue}
  }

  /// 多少秒前转入任务
  public var inTime: Int64 {
    get {return _storage._inTime}
    set {_uniqueStorage()._inTime = newValue}
  }

  /// 多少秒前转出任务
  public var outTime: Int64 {
    get {return _storage._outTime}
    set {_uniqueStorage()._outTime = newValue}
  }

  /// 多少秒前最后活动
  public var lastTime: Int64 {
    get {return _storage._lastTime}
    set {_uniqueStorage()._lastTime = newValue}
  }

  /// 是否已超时
  public var timeout: Int32 {
    get {return _storage._timeout}
    set {_uniqueStorage()._timeout = newValue}
  }

  /// 是否已超时
  public var waitResponse: Int32 {
    get {return _storage._waitResponse}
    set {_uniqueStorage()._waitResponse = newValue}
  }

  /// 是否已超时
  public var isProcess: Int32 {
    get {return _storage._isProcess}
    set {_uniqueStorage()._isProcess = newValue}
  }

  /// 是否已超时
  public var isReceive: Int32 {
    get {return _storage._isReceive}
    set {_uniqueStorage()._isReceive = newValue}
  }

  /// 是转入
  public var isIn: Int32 {
    get {return _storage._isIn}
    set {_uniqueStorage()._isIn = newValue}
  }

  /// 是否转出
  public var isOut: Int32 {
    get {return _storage._isOut}
    set {_uniqueStorage()._isOut = newValue}
  }

  /// 是否可见
  public var visible: Int32 {
    get {return _storage._visible}
    set {_uniqueStorage()._visible = newValue}
  }

  /// 客户状态
  public var state: CommonChatState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// 客服状态
  public var workerState: Api_Common_WorkerState {
    get {return _storage._workerState}
    set {_uniqueStorage()._workerState = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_Core_Pagination: @unchecked Sendable {}
extension Api_Core_ChatListQueryRequest: @unchecked Sendable {}
extension Api_Core_ChatListQueryPageRequest: @unchecked Sendable {}
extension Api_Core_ChatListHistoryRequest: @unchecked Sendable {}
extension Api_Core_ChatListHistoryResponse: @unchecked Sendable {}
extension Api_Core_ChatListQueryResponse: @unchecked Sendable {}
extension Api_Core_ChatListQueryPageResponse: @unchecked Sendable {}
extension Api_Core_ChatMarkReadRequest: @unchecked Sendable {}
extension Api_Core_OrphanResponse: @unchecked Sendable {}
extension Api_Core_MarkRepliedRequest: @unchecked Sendable {}
extension Api_Core_ChatListQueryUserRequest: @unchecked Sendable {}
extension Api_Core_OrphanReq: @unchecked Sendable {}
extension Api_Core_GetChatSessionStateRequest: @unchecked Sendable {}
extension Api_Core_GetChatSessionStateResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api.core"

extension Api_Core_Pagination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Pagination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .same(proto: "pagesize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pagesize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 1)
    }
    if self.pagesize != 0 {
      try visitor.visitSingularInt32Field(value: self.pagesize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_Pagination, rhs: Api_Core_Pagination) -> Bool {
    if lhs.page != rhs.page {return false}
    if lhs.pagesize != rhs.pagesize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ChatListQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatListQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ChatListQueryRequest, rhs: Api_Core_ChatListQueryRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ChatListQueryPageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatListQueryPageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .standard(proto: "worker_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ChatListQueryPageRequest, rhs: Api_Core_ChatListQueryPageRequest) -> Bool {
    if lhs._page != rhs._page {return false}
    if lhs.workerID != rhs.workerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ChatListHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatListHistoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
    4: .same(proto: "batch"),
    5: .standard(proto: "consult_id"),
    6: .standard(proto: "owner_id"),
    7: .same(proto: "nickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.consultID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.ownerID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.consultID != 0 {
      try visitor.visitSingularUInt32Field(value: self.consultID, fieldNumber: 5)
    }
    if self.ownerID != 0 {
      try visitor.visitSingularInt32Field(value: self.ownerID, fieldNumber: 6)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ChatListHistoryRequest, rhs: Api_Core_ChatListHistoryRequest) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs._batch != rhs._batch {return false}
    if lhs.consultID != rhs.consultID {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ChatListHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatListHistoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chats"),
    2: .same(proto: "batch"),
    3: .same(proto: "total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._batch) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 1)
    }
    try { if let v = self._batch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ChatListHistoryResponse, rhs: Api_Core_ChatListHistoryResponse) -> Bool {
    if lhs.chats != rhs.chats {return false}
    if lhs._batch != rhs._batch {return false}
    if lhs.total != rhs.total {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ChatListQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatListQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ChatListQueryResponse, rhs: Api_Core_ChatListQueryResponse) -> Bool {
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ChatListQueryPageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatListQueryPageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "chats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ChatListQueryPageResponse, rhs: Api_Core_ChatListQueryPageResponse) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.chats != rhs.chats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ChatMarkReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatMarkReadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "consult_id"),
    3: .standard(proto: "msg_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.consultID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.consultID != 0 {
      try visitor.visitSingularInt64Field(value: self.consultID, fieldNumber: 2)
    }
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ChatMarkReadRequest, rhs: Api_Core_ChatMarkReadRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.consultID != rhs.consultID {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_OrphanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrphanResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .same(proto: "nick"),
    3: .same(proto: "avatar"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nick) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if !self.nick.isEmpty {
      try visitor.visitSingularStringField(value: self.nick, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_OrphanResponse, rhs: Api_Core_OrphanResponse) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.nick != rhs.nick {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_MarkRepliedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarkRepliedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "consult_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.consultID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.consultID != 0 {
      try visitor.visitSingularInt64Field(value: self.consultID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_MarkRepliedRequest, rhs: Api_Core_MarkRepliedRequest) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.consultID != rhs.consultID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_ChatListQueryUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatListQueryUserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "register_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.registerType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if self.registerType != 0 {
      try visitor.visitSingularInt32Field(value: self.registerType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_ChatListQueryUserRequest, rhs: Api_Core_ChatListQueryUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.registerType != rhs.registerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_OrphanReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrphanReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "consult_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.consultID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.consultID != 0 {
      try visitor.visitSingularInt64Field(value: self.consultID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_OrphanReq, rhs: Api_Core_OrphanReq) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.consultID != rhs.consultID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_GetChatSessionStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatSessionStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .standard(proto: "consult_id"),
    3: .standard(proto: "owner_id"),
    4: .standard(proto: "owner_role"),
    5: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.consultID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.ownerID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.ownerRole) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantID != 0 {
      try visitor.visitSingularInt32Field(value: self.tenantID, fieldNumber: 1)
    }
    if self.consultID != 0 {
      try visitor.visitSingularInt64Field(value: self.consultID, fieldNumber: 2)
    }
    if self.ownerID != 0 {
      try visitor.visitSingularInt32Field(value: self.ownerID, fieldNumber: 3)
    }
    if self.ownerRole != 0 {
      try visitor.visitSingularInt32Field(value: self.ownerRole, fieldNumber: 4)
    }
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_GetChatSessionStateRequest, rhs: Api_Core_GetChatSessionStateRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.consultID != rhs.consultID {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.ownerRole != rhs.ownerRole {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Core_GetChatSessionStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChatSessionStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tenant_id"),
    2: .standard(proto: "consult_id"),
    3: .standard(proto: "owner_id"),
    4: .standard(proto: "owner_role"),
    6: .standard(proto: "assign_time"),
    7: .standard(proto: "session_start_time"),
    8: .standard(proto: "client_message_time"),
    31: .standard(proto: "client_first_time"),
    9: .standard(proto: "worker_id"),
    10: .standard(proto: "worker_ping_time"),
    32: .standard(proto: "worker_first_time"),
    11: .standard(proto: "worker_message_time"),
    13: .standard(proto: "worker_consult_id"),
    14: .standard(proto: "in_time"),
    15: .standard(proto: "out_time"),
    35: .standard(proto: "last_time"),
    16: .same(proto: "timeout"),
    56: .standard(proto: "wait_response"),
    57: .standard(proto: "is_process"),
    58: .standard(proto: "is_receive"),
    59: .standard(proto: "is_in"),
    60: .standard(proto: "is_out"),
    17: .same(proto: "visible"),
    20: .same(proto: "state"),
    21: .standard(proto: "worker_state"),
  ]

  fileprivate class _StorageClass {
    var _tenantID: Int32 = 0
    var _consultID: Int64 = 0
    var _ownerID: Int32 = 0
    var _ownerRole: Int32 = 0
    var _assignTime: Int64 = 0
    var _sessionStartTime: Int64 = 0
    var _clientMessageTime: Int64 = 0
    var _clientFirstTime: Int64 = 0
    var _workerID: Int32 = 0
    var _workerPingTime: Int64 = 0
    var _workerFirstTime: Int64 = 0
    var _workerMessageTime: Int64 = 0
    var _workerConsultID: Int64 = 0
    var _inTime: Int64 = 0
    var _outTime: Int64 = 0
    var _lastTime: Int64 = 0
    var _timeout: Int32 = 0
    var _waitResponse: Int32 = 0
    var _isProcess: Int32 = 0
    var _isReceive: Int32 = 0
    var _isIn: Int32 = 0
    var _isOut: Int32 = 0
    var _visible: Int32 = 0
    var _state: CommonChatState = .common
    var _workerState: Api_Common_WorkerState = .workerOffline

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _tenantID = source._tenantID
      _consultID = source._consultID
      _ownerID = source._ownerID
      _ownerRole = source._ownerRole
      _assignTime = source._assignTime
      _sessionStartTime = source._sessionStartTime
      _clientMessageTime = source._clientMessageTime
      _clientFirstTime = source._clientFirstTime
      _workerID = source._workerID
      _workerPingTime = source._workerPingTime
      _workerFirstTime = source._workerFirstTime
      _workerMessageTime = source._workerMessageTime
      _workerConsultID = source._workerConsultID
      _inTime = source._inTime
      _outTime = source._outTime
      _lastTime = source._lastTime
      _timeout = source._timeout
      _waitResponse = source._waitResponse
      _isProcess = source._isProcess
      _isReceive = source._isReceive
      _isIn = source._isIn
      _isOut = source._isOut
      _visible = source._visible
      _state = source._state
      _workerState = source._workerState
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._tenantID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._consultID) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._ownerID) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._ownerRole) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._assignTime) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._sessionStartTime) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._clientMessageTime) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._workerID) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._workerPingTime) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._workerMessageTime) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._workerConsultID) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._inTime) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._outTime) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._timeout) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._visible) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._workerState) }()
        case 31: try { try decoder.decodeSingularInt64Field(value: &_storage._clientFirstTime) }()
        case 32: try { try decoder.decodeSingularInt64Field(value: &_storage._workerFirstTime) }()
        case 35: try { try decoder.decodeSingularInt64Field(value: &_storage._lastTime) }()
        case 56: try { try decoder.decodeSingularInt32Field(value: &_storage._waitResponse) }()
        case 57: try { try decoder.decodeSingularInt32Field(value: &_storage._isProcess) }()
        case 58: try { try decoder.decodeSingularInt32Field(value: &_storage._isReceive) }()
        case 59: try { try decoder.decodeSingularInt32Field(value: &_storage._isIn) }()
        case 60: try { try decoder.decodeSingularInt32Field(value: &_storage._isOut) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._tenantID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tenantID, fieldNumber: 1)
      }
      if _storage._consultID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._consultID, fieldNumber: 2)
      }
      if _storage._ownerID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ownerID, fieldNumber: 3)
      }
      if _storage._ownerRole != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ownerRole, fieldNumber: 4)
      }
      if _storage._assignTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._assignTime, fieldNumber: 6)
      }
      if _storage._sessionStartTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sessionStartTime, fieldNumber: 7)
      }
      if _storage._clientMessageTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._clientMessageTime, fieldNumber: 8)
      }
      if _storage._workerID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._workerID, fieldNumber: 9)
      }
      if _storage._workerPingTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workerPingTime, fieldNumber: 10)
      }
      if _storage._workerMessageTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workerMessageTime, fieldNumber: 11)
      }
      if _storage._workerConsultID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workerConsultID, fieldNumber: 13)
      }
      if _storage._inTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._inTime, fieldNumber: 14)
      }
      if _storage._outTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._outTime, fieldNumber: 15)
      }
      if _storage._timeout != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timeout, fieldNumber: 16)
      }
      if _storage._visible != 0 {
        try visitor.visitSingularInt32Field(value: _storage._visible, fieldNumber: 17)
      }
      if _storage._state != .common {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 20)
      }
      if _storage._workerState != .workerOffline {
        try visitor.visitSingularEnumField(value: _storage._workerState, fieldNumber: 21)
      }
      if _storage._clientFirstTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._clientFirstTime, fieldNumber: 31)
      }
      if _storage._workerFirstTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workerFirstTime, fieldNumber: 32)
      }
      if _storage._lastTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastTime, fieldNumber: 35)
      }
      if _storage._waitResponse != 0 {
        try visitor.visitSingularInt32Field(value: _storage._waitResponse, fieldNumber: 56)
      }
      if _storage._isProcess != 0 {
        try visitor.visitSingularInt32Field(value: _storage._isProcess, fieldNumber: 57)
      }
      if _storage._isReceive != 0 {
        try visitor.visitSingularInt32Field(value: _storage._isReceive, fieldNumber: 58)
      }
      if _storage._isIn != 0 {
        try visitor.visitSingularInt32Field(value: _storage._isIn, fieldNumber: 59)
      }
      if _storage._isOut != 0 {
        try visitor.visitSingularInt32Field(value: _storage._isOut, fieldNumber: 60)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_Core_GetChatSessionStateResponse, rhs: Api_Core_GetChatSessionStateResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tenantID != rhs_storage._tenantID {return false}
        if _storage._consultID != rhs_storage._consultID {return false}
        if _storage._ownerID != rhs_storage._ownerID {return false}
        if _storage._ownerRole != rhs_storage._ownerRole {return false}
        if _storage._assignTime != rhs_storage._assignTime {return false}
        if _storage._sessionStartTime != rhs_storage._sessionStartTime {return false}
        if _storage._clientMessageTime != rhs_storage._clientMessageTime {return false}
        if _storage._clientFirstTime != rhs_storage._clientFirstTime {return false}
        if _storage._workerID != rhs_storage._workerID {return false}
        if _storage._workerPingTime != rhs_storage._workerPingTime {return false}
        if _storage._workerFirstTime != rhs_storage._workerFirstTime {return false}
        if _storage._workerMessageTime != rhs_storage._workerMessageTime {return false}
        if _storage._workerConsultID != rhs_storage._workerConsultID {return false}
        if _storage._inTime != rhs_storage._inTime {return false}
        if _storage._outTime != rhs_storage._outTime {return false}
        if _storage._lastTime != rhs_storage._lastTime {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._waitResponse != rhs_storage._waitResponse {return false}
        if _storage._isProcess != rhs_storage._isProcess {return false}
        if _storage._isReceive != rhs_storage._isReceive {return false}
        if _storage._isIn != rhs_storage._isIn {return false}
        if _storage._isOut != rhs_storage._isOut {return false}
        if _storage._visible != rhs_storage._visible {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._workerState != rhs_storage._workerState {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
